# run_simulation.py
import os
import numpy as np
import matplotlib.pyplot as plt
from tqdm import tqdm
import csv

from utils import load_mat, regularize_covariance, estimate_noise_covariance
from solvers import fit_mri_params_lrt, fit_mri_params_bayesian

# --- Configuration ---
REPO_ROOT = os.path.dirname(os.path.abspath(__file__))
DATA_DIR = os.path.join(REPO_ROOT, 'data', 'simulation_phantom')
DICT_DIR = os.path.join(REPO_ROOT, 'data', 'dictionaries')

SNR_DB = 15
T2_ARRAY = np.arange(20, 301, 5) # Reduced step for speed in Python example
B1_SIM = 1.0
N_SIM = 1000
ALPHA = 0.05
USE_IDENTITY_COV = True # Flag from your recent request

if USE_IDENTITY_COV:
    OUT_DIR = os.path.join(REPO_ROOT, 'python_output', 'simulation_results_identity')
else:
    OUT_DIR = os.path.join(REPO_ROOT, 'python_output', 'simulation_results')
    
os.makedirs(OUT_DIR, exist_ok=True)

# --- Main Loop ---
def main():
    np.random.seed(2025)
    
    contrast_modes = ['TE', 'PC']
    b1_modes = [True, False]
    
    plot_data = []

    for contrast_type in contrast_modes:
        print(f"\n=== Processing {contrast_type} ===")
        
        # Load Data
        try:
            h_data = load_mat(os.path.join(DATA_DIR, 'header.mat'))
            c_data = load_mat(os.path.join(DATA_DIR, 'contrast.mat'))
            d_data = load_mat(os.path.join(DICT_DIR, f'simulation_{contrast_type}.mat'))
            
            contrast = c_data['contrast'] # [Nx, Ny, Nt_orig]
            D = d_data['D']
        except FileNotFoundError as e:
            print(f"Error loading files: {e}")
            continue

        # Handle PC Projection
        if contrast_type == 'PC':
            basis = D['u']
            nx, ny, n_orig = contrast.shape
            
            # Reshape for projection: Python is row-major, MATLAB is col-major. 
            # We must be careful. If contrast came from MATLAB, treat as 'F'.
            c_flat = contrast.reshape(nx*ny, n_orig, order='F')
            
            # Project: (NxNy x N_orig) * (N_orig x Nt)
            c_proj = c_flat @ basis
            contrast = c_proj.reshape(nx, ny, -1, order='F')
            N_t = basis.shape[1]
        else:
            N_t = h_data['header']['etl']

        # --- Noise Setup ---
        # 1. Estimate realistic background covariance
        contrast_dbl = contrast.astype(np.float64) * 1e4
        sigma_bg = estimate_noise_covariance(contrast_dbl, frame_size=10)
        
        # 2. Scale for Simulation
        sig_norm = 1.0
        snr_lin = 10**(SNR_DB / 10.0)
        cov_scale = sig_norm**2 / (snr_lin**2 * np.trace(sigma_bg))
        
        sigma_sim = regularize_covariance(cov_scale * sigma_bg, 500)
        
        # Create Complex Generator Matrix for MVN
        # Real-valued covariance for [Re, Im] stack
        Sigma_w = np.block([
            [np.real(sigma_sim), -np.imag(sigma_sim)],
            [np.imag(sigma_sim),  np.real(sigma_sim)]
        ])
        
        # 3. Fitting Covariance
        if USE_IDENTITY_COV:
            sigma_fit = np.eye(N_t)
        else:
            sigma_fit = sigma_sim
            
        # --- B1 Loops ---
        dict_atoms = D['magnetization']
        dict_lut = D['lookup_table']
        
        for use_b1_map in b1_modes:
            if use_b1_map:
                lbl = f"{contrast_type} Constrained B1"
                b1_mode_str = 'range'
                b1_input_range = np.array([0.9, 1.1])
                csv_tag = 'ConstrainedB1'
                color = 'r' if contrast_type == 'TE' else 'b'
            else:
                lbl = f"{contrast_type} Free B1"
                b1_mode_str = 'none'
                b1_input_range = None
                csv_tag = 'FreeB1'
                color = 'k' if contrast_type == 'TE' else 'm'
                
            print(f"  > Running {lbl}...")
            
            res_struct = {
                'T2': [], 'LRT_Cov': [], 'Bayes_Cov': [], 
                'LRT_Size': [], 'Bayes_Size': []
            }
            
            # --- Monte Carlo Loop ---
            for t2_true in tqdm(T2_ARRAY):
                # Find atom
                dist = np.abs(dict_lut[:,0] - B1_SIM) + np.abs(dict_lut[:,1] - t2_true)
                idx = np.argmin(dist)
                clean_sig = dict_atoms[:, idx]
                clean_sig = clean_sig / np.linalg.norm(clean_sig) * sig_norm
                
                # Generate Noise
                noise_ri = np.random.multivariate_normal(
                    np.zeros(2*N_t), Sigma_w, N_SIM
                )
                noise_c = noise_ri[:, :N_t] + 1j * noise_ri[:, N_t:]
                
                # [N_sim, Nt] -> [N_sim, 1, Nt] to simulate "image"
                noisy_sigs = (clean_sig[None, :] + noise_c).reshape(N_sim_img(N_SIM), order='F')
                
                # Options
                ops = {'alpha': ALPHA, 'b1_mode': b1_mode_str}
                if use_b1_map:
                    # [Nx, Ny, 2] -> [N_sim, 1, 2]
                    ops['b1_input'] = np.tile(b1_input_range, (N_SIM, 1, 1))
                
                # Run Solvers
                # Note: fits expect [Nx, Ny, Nt]. We fake it as [N_sim, 1, Nt]
                _, lrt_res = fit_mri_params_lrt(noisy_sigs, sigma_fit, D, ops)
                _, bayes_res = fit_mri_params_bayesian(noisy_sigs, sigma_fit, D, ops)
                
                # Stats
                l_ci = lrt_res['q_ci']
                b_ci = bayes_res['q_ci']
                
                l_cov = np.mean((t2_true >= l_ci[:,0]) & (t2_true <= l_ci[:,1])) * 100
                b_cov = np.mean((t2_true >= b_ci[:,0]) & (t2_true <= b_ci[:,1])) * 100
                
                l_sz = np.nanmean(l_ci[:,1] - l_ci[:,0])
                b_sz = np.nanmean(b_ci[:,1] - b_ci[:,0])
                
                res_struct['T2'].append(t2_true)
                res_struct['LRT_Cov'].append(l_cov)
                res_struct['Bayes_Cov'].append(b_cov)
                res_struct['LRT_Size'].append(l_sz)
                res_struct['Bayes_Size'].append(b_sz)
                
            # Store for plotting
            plot_data.append({'label': lbl, 'color': color, 'res': res_struct})
            
            # Save CSV
            csv_path = os.path.join(OUT_DIR, f'sim_results_{SNR_DB}dB_{contrast_type}_{csv_tag}.csv')
            with open(csv_path, 'w', newline='') as f:
                writer = csv.writer(f)
                writer.writerow(['T2', 'LRT_Cov', 'Bayes_Cov', 'LRT_Size', 'Bayes_Size'])
                rows = zip(res_struct['T2'], res_struct['LRT_Cov'], res_struct['Bayes_Cov'], 
                           res_struct['LRT_Size'], res_struct['Bayes_Size'])
                writer.writerows(rows)

    plot_results(plot_data, OUT_DIR)

def N_sim_img(n_sim):
    # Helper to shape (N_sim, 1, Nt)
    return (n_sim, 1, -1)

def plot_results(data, out_dir):
    # Figure 1: Coverage
    plt.figure(figsize=(10, 6))
    plt.axhline(95, color='gray', linestyle='--')
    for d in data:
        r = d['res']
        plt.plot(r['T2'], r['LRT_Cov'], linestyle='--', color=d['color'], label=f"LRT {d['label']}")
        plt.plot(r['T2'], r['Bayes_Cov'], linestyle=':', color=d['color'], label=f"Bayes {d['label']}")
    plt.ylim(70, 101)
    plt.xlabel('T2 (ms)')
    plt.ylabel('Coverage (%)')
    plt.legend(ncol=2)
    plt.savefig(os.path.join(out_dir, 'MASTER_coverage.png'))
    
    # Figure 2: Size
    plt.figure(figsize=(10, 6))
    for d in data:
        r = d['res']
        plt.plot(r['T2'], r['LRT_Size'], linestyle='--', color=d['color'], label=f"LRT {d['label']}")
        plt.plot(r['T2'], r['Bayes_Size'], linestyle=':', color=d['color'], label=f"Bayes {d['label']}")
    plt.xlabel('T2 (ms)')
    plt.ylabel('Interval Size (ms)')
    plt.legend(ncol=2)
    plt.savefig(os.path.join(out_dir, 'MASTER_size.png'))

if __name__ == "__main__":
    main()
